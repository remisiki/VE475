\section{Implementation}
To suit various applications of MAC with different requirements, many different implementations 
of MAC are proposed. 
Among them, HMAC is a group of MAC generation algorithms based on hash functions 
like \emph{MD5} and \emph{SHA family}.
At the same time, \emph{Poly1305-AES} is another typical algorithm based on \emph{AES}, 
which has advantage in speed. 
\subsection{HMAC}
In \cite{HMAC}, \emph{HMAC} method is introduced, which fully takes the advantage of 
hash functions that it can map input with any length into a fix-length output. 
To add more randomness to output and improve the security, some extra steps are taken 
in \emph{HMAC} algorithm. 
The overall process of \emph{HMAC} can be represented by the formula
$$
\text{HMAC}_k(x)=F(\overline{k}\oplus\text{opad}|F(\overline{k}\oplus\text{ipad}|x))
$$
where $F$ is a key-less hash function, $\oplus$ denotes bit-wise XOR operation, 
$|$ denotes concatenation and $\overline{k}$ is completed key. 
Here, \emph{HMAC} based on \emph{SHA-1} will be taken as the example. 

To calculate this equation, first they key $k$ should be processed because its 
length may not satisfy requirements. In \emph{HMAC}, the key length is expected 
to be 512 bits. If $k$ is exactly 512-bit long, nothing needs to be done and 
$\overline{k}=k$. 
If $k$ is shorter than 512 bits, 0's are appended until the length reaches 512 bits. 
When it is longer than 512 bits, hash function $F$ is applied to reduce length and 
then 0's are appended to form 512-bit $\overline{k}$. 

\emph{opad} and \emph{ipad} are also easy to obtained, because they are 
simply repetition of fixed bytes. 
\emph{opad} is a repetition of 0x36 while \emph{ipad} is obtained by repeating 
0x5C. To match the length of $\overline{k}$, the bytes are repeated by $512/8=64$ times.

With preparation done, \emph{MAC} can be finally calculated. 
Input message $x$ is first concatenated to the right of $\overline{k}\oplus\text{ipad}$, 
and then fed to hash function \emph{SHA-1}. 
\emph{SHA-1} function will always return with a 160-bit long output, which will be  
concatenated to the right of $\overline{k}\oplus\text{opad}$ and inputted into 
\emph{SHA-1} again. 
This time, the output is exactly the final output of \emph{HMAC} algorithm. 
\subsubsection{SHA-1}
To make the whole process clear, \emph{SHA-1} algorithm described by \cite{SHA} is also introduced here. 
The overall structure of \emph{SHA-1} is that input are divided into blocks, on which 
the same process will be applied. At the same time, theses processes are chained 
together so that former blocks have influence on latter blocks. 

First, input is divided in to 512-bit long blocks. 
To assure the completion of the last block, padding method is applied. 
The input is first appended with a 1, followed by several 0's. Finally, 
the length of original input is attached as a 64-bit integer. 
The number of 0's is determined by the final goal that, including the 64-bit length, 
total length is a multiple of 512. 

After blocks are divided, chained calculation is conducted on them. 
First, global variables $H_j, 0\le j\le 4$ are introduced, each of which has 
a length of 32 bits. 
They are initialized before the first block is processed, 
$$
H_0=\text{67452301}, 
H_1=\text{EFCDAB89}, 
H_2=\text{98BADCFE}, 
H_3=\text{10325476}, 
H_4=\text{C3D2E1F0}
$$

Then comes to the operation on each block, which takes 80 rounds.  
To support operation of 80 rounds for each block, an array $W_i$ of 32-bit 
numbers is used. 
The first 16 element, $W_0$ to $W_{15}$ are the input in this block, which is exactly 
512 bits. 
As for latter elements, they are generated by the equation 
$$
W_i=W_{i-3}\oplus W_{i-8}\oplus W_{i-14}\oplus W_{i-16}
$$

Before starting 80 rounds of calculation, temperate variables $A, B, C, D, E$ 
are assigned by the values of $H_0$ to $H_4$ respectively. 
Then in $i$th round, the follow process is done 
(here numbers are always 32-bit and overflow part will be ignored)
$$
\begin{cases}
\text{TEMP}=S^5(A)+f_i(B, C, D)+E+W_i+K_i\\
E=D\\D=C\\C=S^{30}(B)\\B=A\\A=\text{TEMP}
\end{cases}
$$
In the equations, $S^k$ denotes cyclic left shifting for $k$ bits, and $f_i$, $K_i$ 
are defined as follows 
$$
\begin{cases}
f_i(B,C,D)=(B\land C)\vee(~B\land D), (0\le i\le 19)\\
f_i(B,C,D)=B\oplus C\oplus D, (20\le i\le 39)\\
f_i(B,C,D)=(B\land C)\vee(B\land D)\vee(C\land D), (40\le i\le 59)\\
f_i(B,C,D)=B\oplus C\oplus D, (60\le i\le 79)
\end{cases}
$$
$$
\begin{cases}
K_i=\text{5A827999}, (0\le i\le19)\\
K_i=\text{6ED9EBA1}, (20\le i\le39)\\
K_i=\text{8F1BBCDC}, (40\le i\le59)\\
K_i=\text{CA62C1D6}, (60\le i\le79)
\end{cases}
$$
Both of them depends on the round index. 

After 80 round, results are chained by $H_0=H_0+A, H_1=H_1+B, H_2=H_2+C, H_3=H_3+D, 
H_4=H_4+E$. It easy to sea that results accumulate in $H_i$ after processing of all 
the blocks are completed. 
The concatenation of these 5 variables give the final output, which is $32\times5=160$ bits. 
\subsection{Poly1305-AES}
As is indicated in the name, this method proposed in \cite{Poly1305} 
based on both \emph{AES} algorithm and polynomial calculation. 
To run \emph{Poly1305-AES}, an 128-bit nonce $n$ and another 256-bit secrete key 
should be given along with the message $m$. 

First, the secret key should meet some satisfactions. 
The secret key will be regarded as a concatenation of two 128-bit parts, 
$(k, r)$. $k$ is the key used for \emph{AES} processing, 
while $r$ is regarded a combination of 16 little-endian unsigned numbers. 
Denoting them by $r[0], r[1], \cdots, r[15]$, the upper 4 bits of 
$r[3], r[7], r[11], r[15]$ have to be 0 and the lower 2 bits of 
$r[4], r[8], [12]$ should be 0 too. 

Second, the message should be padded to suit this algorithm. 
Message $m$ is firstly divided into chucks of 128 bits, 
and then appended with 0x01. 
After this, all chunks except the last one are 136-bits long, so 0's 
may be attached to the last chunk such that all chunks have the same length. 
After padding, $m$ is also regarded as a array $c_1, c_2, \cdots, c_q, 
q=\lceil\text{length of }m/16\rceil$
each of which is a 136-bit unsigned number.

Being prepare, the final output of this algorithm is given by 
$$
(((c_1r^q+c_2r^{q-1}+\cdots+c_qr^1)\mod{2^{130}})+\text{AES}_k(n)))\mod{2^{128}}
$$
The \emph{AES} here takes 128-bit key and 128-bit input and returns an 128-bit output, 
which is done in one block. 

Due to modular powering and \emph{AES}, final result looks random while carrying 
authentication information of the message. 
